import { BaseKernel } from '@jupyterlite/kernel';
import { KernelMessage } from '@jupyterlab/services';
import { ServiceContainer } from './services/ServiceContainer';

const reconnectString: string = "%connect%"
const saveString: string = "%save%";
const bootFileName: string = "boot.py";
const bootSavePrefix: string = `with open('${bootFileName}', 'w') as f:\n    f.write('''\n`;
const bootSaveSuffix: string = "\n''')\n";

export class EmbeddedKernel extends BaseKernel {

  constructor(options: any, private serviceContainer: ServiceContainer) {
    super(options);
  }

  async kernelInfoRequest(): Promise<KernelMessage.IInfoReplyMsg['content']> {
    const content: KernelMessage.IInfoReply = {
      implementation: 'embedded',
      implementation_version: '0.1.0',
      language_info: {
        codemirror_mode: {
          name: 'python',
          version: 3,
        },
        file_extension: '.py',
        mimetype: 'text/x-python',
        name: 'python',
        nbconvert_exporter: 'python',
        pygments_lexer: 'ipython3',
        version: '3.8',
      },
      protocol_version: '5.3',
      status: 'ok',
      banner: 'Embedded Kernel with Serial Support',
      help_links: [],
    };

    return content;
  }

  async interrupt(): Promise<void> {
    await this.serviceContainer.deviceService.sendInterrupt();
  }

  outputResponse(msg: string): void {
    console.log("[Kernel] outputResponse - Streaming output:", msg);
    
    msg += '\n';
    
    this.stream({
      name: 'stdout',
      text: msg,
    })
  }

  async executeRequest(
    content: KernelMessage.IExecuteRequestMsg['content'],
  ): Promise<KernelMessage.IExecuteReplyMsg['content']> {

    console.log("[Kernel] executeRequest - Starting execution");
    if (this.serviceContainer.deviceService == undefined){
      console.log("[Kernel] executeRequest - DeviceService is undefined");
      return {
          status: 'error',
          execution_count: this.executionCount,
          ename: 'ValueError',
          evalue: 'Missing MicroPython firmware URL',
          traceback: ['Please provide MicroPython firmware URL']
        };
    }

    console.log("[Kernel] executeRequest - Processing code");
    const { code } = content;


    if (code.includes(reconnectString)) {
      // Reconnect the device or connect for the first time
      this.outputResponse("Reconnect command detected, reconnecting device...");
      await this.serviceContainer.deviceService.disconnect();
      await this.serviceContainer.deviceService.connect(this.outputResponse.bind(this));
    }
    if (code.includes(saveString)) {
      // Burn the code after the save string into the boot.py file
      this.outputResponse("Save command detected, saving code to boot.py...");
      const codeToSave = code.split(saveString)[1].trim();
      if (!codeToSave) {
        return {
          status: 'error',
          execution_count: this.executionCount,
          ename: 'ValueError',
          evalue: 'No code provided to save',
          traceback: ['Please provide code to save after the %save% command']
        };
      }
      // Burn the code by adding it to the boot.py file. Can call executeRequest with the code to save 
      // but append the code to write it to the boot.py file at the start of the code.
      const bootCode = `# This code is automatically generated by the Embedded Kernel\n${codeToSave}`;
      const bootCodeWithSave = `${bootSavePrefix}${bootCode}${bootSaveSuffix}`;

      // Execute the command to save the boot.py file
      if (!this.serviceContainer.deviceService.getTransport()) {
        console.log("[Kernel] executeRequest - No transport available for saving boot.py");
        return {
          status: 'error',
          execution_count: this.executionCount,
          ename: 'TransportError',
          evalue: 'No transport available to save boot.py',
          traceback: ['Please connect a device first']
        };
      }
      const result = await this.serviceContainer.consoleService.executeCommand(bootCodeWithSave, (content) => {
        console.log("[Kernel] executeRequest - Streaming output:", content);
        this.stream(content);
      });
      if (!result.success) {
        console.log("[Kernel] executeRequest - Command execution failed:", result.error);
        return {
          status: 'error',
          execution_count: this.executionCount,
          ename: 'ExecutionError',
          evalue: result.error || 'Unknown error',
          traceback: [result.error || 'Unknown error']
        };
      }
      console.log("[Kernel] executeRequest - Code saved to boot.py successfully");
      return {
        status: 'ok',
        execution_count: this.executionCount,
        user_expressions: {},
      };
    }

    try {
      console.log("[Kernel] executeRequest - Checking transport");
      const transport = this.serviceContainer.deviceService.getTransport();
      console.log(transport)
      if (!transport) {
        console.log("[Kernel] executeRequest - No transport available");
        return {
          status: 'error',
          execution_count: this.executionCount,
          ename: 'TransportError',
          evalue: 'No transport available',
          traceback: ['Please connect a device first']
        };
      }
      
      

      console.log("[Kernel] executeRequest - Executing command via ConsoleService");
      // Execute the command and handle the output
      const result = await this.serviceContainer.consoleService.executeCommand(code, (content) => {
        console.log("[Kernel] executeRequest - Streaming output:", content);
        this.stream(content);
      });

      if (!result.success) {
        console.log("[Kernel] executeRequest - Command execution failed:", result.error);
        return {
          status: 'error',
          execution_count: this.executionCount,
          ename: 'ExecutionError',
          evalue: result.error || 'Unknown error',
          traceback: [result.error || 'Unknown error']
        };
      }

      console.log("[Kernel] executeRequest - Command executed successfully");
      return {
        status: 'ok',
        execution_count: this.executionCount,
        user_expressions: {},
      };

    } catch (error: any) {
      console.error("[Kernel] executeRequest - Execution error:", error);
      return {
        status: 'error',
        execution_count: this.executionCount,
        ename: 'ExecuteError',
        evalue: error instanceof Error ? error.message : 'Unknown error',
        traceback: error instanceof Error ? [error.stack || ''] : ['Unknown error occurred'],
      };
    }
  }

  async completeRequest(
    content: KernelMessage.ICompleteRequestMsg['content'],
  ): Promise<KernelMessage.ICompleteReplyMsg['content']> {
    throw new Error('Not implemented');
  }

  async inspectRequest(
    content: KernelMessage.IInspectRequestMsg['content'],
  ): Promise<KernelMessage.IInspectReplyMsg['content']> {
    throw new Error('Not implemented');
  }

  async isCompleteRequest(
    content: KernelMessage.IIsCompleteRequestMsg['content'],
  ): Promise<KernelMessage.IIsCompleteReplyMsg['content']> {
    throw new Error('Not implemented');
  }

  async commInfoRequest(
    content: KernelMessage.ICommInfoRequestMsg['content'],
  ): Promise<KernelMessage.ICommInfoReplyMsg['content']> {
    throw new Error('Not implemented');
  }

  inputReply(content: KernelMessage.IInputReplyMsg['content']): void {}

  async commOpen(msg: KernelMessage.ICommOpenMsg): Promise<void> {}

  async commMsg(msg: KernelMessage.ICommMsgMsg): Promise<void> {}

  async commClose(msg: KernelMessage.ICommCloseMsg): Promise<void> {}
}
